// File: src/geomopt.cpp
#include "geomopt.hpp"
#include "matrix.hpp"
#include "rfo.hpp"
#include "bfgs.hpp"
#include "gdiis.hpp"
#include "gediis.hpp"
#include "line_search.hpp"
#include <cstdio>
#include <iostream>
#include <cmath>

// --- Gaussian 收敛检查工具函数 ---
static bool check_convergence(double gMax, double gRMS,
                              double dMax, double dRMS,
                              double gMaxTol, double gRMSTol,
                              double dMaxTol, double dRMSTol) {
    return (gMax < gMaxTol) && (gRMS < gRMSTol) &&
           (dMax < dMaxTol) && (dRMS < dRMSTol);
}

// --- 计算梯度最大值和 RMS ---
static double max_grad(const Matrix& g) {
    double gMax = 0.0;
    for (std::size_t i = 0; i < g.rows(); ++i) {
        double g2 = g(i,0)*g(i,0) + g(i,1)*g(i,1) + g(i,2)*g(i,2);
        gMax = std::max(gMax, std::sqrt(g2));
    }
    return gMax;
}
static double rms_grad(const Matrix& g) {
    double gRMS = 0.0;
    for (std::size_t i = 0; i < g.rows(); ++i) {
        gRMS += g(i,0)*g(i,0) + g(i,1)*g(i,1) + g(i,2)*g(i,2);
    }
    return std::sqrt(gRMS / g.rows());
}

// --- 计算位移最大值和 RMS ---
static double max_disp(const Matrix& dx) {
    double dMax = 0.0;
    for (std::size_t i = 0; i < dx.rows(); ++i) {
        double d2 = dx(i,0)*dx(i,0) + dx(i,1)*dx(i,1) + dx(i,2)*dx(i,2);
        dMax = std::max(dMax, std::sqrt(d2));
    }
    return dMax;
}
static double rms_disp(const Matrix& dx) {
    double dRMS = 0.0;
    for (std::size_t i = 0; i < dx.rows(); ++i) {
        dRMS += dx(i,0)*dx(i,0) + dx(i,1)*dx(i,1) + dx(i,2)*dx(i,2);
    }
    return std::sqrt(dRMS / dx.rows());
}


// ---------- GeomOpt ----------
GeomOpt::GeomOpt(Cell& cell) : cell(cell), hess(cell.coords.size()) {}

bool GeomOpt::run(double maxGrad, 
                  double rmsGrad, 
                  double maxDisp,
                  double rmsDisp,
                  std::size_t maxCycle) {
    const std::size_t nAtom = cell.num_atoms();

    GDIIS  gdiis (3 * nAtom);
    GEDIIS gediis(3 * nAtom);

    for (std::size_t cycle = 0; cycle < maxCycle; ++cycle) {
        std::printf("cycle = %zu    ", cycle);

        // === 1) 从 Gaussian 得到本轮梯度与能量 ===
        // 说明：calculate_gradient_from_gauss() 会写 gauss.gjf 并调用 g16 生成 gauss.log
        Matrix x = cell.coords;                          // 当前坐标（nAtom x 3）
        Matrix g = cell.calculate_gradient_from_gauss(); // 本轮梯度（会触发 g16）
        double E = cell.get_energy_from_gauss();        // 从同一个 gauss.log 里取能量


        Matrix xv = x.reshape(3*nAtom, 1);
        Matrix gv = g.reshape(3*nAtom, 1);

        // 将真实的Gaussian计算结果添加到历史记录
        // 重要：历史记录应该只包含真实的量化计算结果，不包含插值/拟合数据
        xHist.push_back(xv);
        gHist.push_back(gv);
        EHist.push_back(E);
        // === 线搜索功能：目前禁用，专注于纯RFO优化 ===
        // 原因：经过多次调试，线搜索没有显著改善收敛性能，有时甚至增加步数
        // 纯RFO + trust radius控制已经能很好地处理步长问题
        
        std::cout << "Line search disabled - using pure RFO optimization" << std::endl;
        
        // === 纯RFO：基本收敛检查（使用Gaussian收敛判据）===
        const double gMax = max_grad(g);
        const double gRMS = rms_grad(g);
        std::printf("max grad = %.6lf, rms grad = %.6lf\n", gMax, gRMS);

        // 使用Gaussian收敛判据作为收敛条件
        if (cell.is_converged_from_gauss("gauss.log")) {
            std::cout << "✅ Pure RFO converged (Gaussian criteria satisfied)\n";
            return true;
        }

        // === 纯RFO：使用BFGS Hessian更新（对RFO性能很重要）===
        hess.update_hessian_bfgs(xv, gv);  // BFGS更新对RFO收敛很重要
        Matrix H = hess.hessian();

        // === 纯RFO步长计算 ===
        std::cout << "pure rfo step" << std::endl;
        Matrix xnew = rfo_step(xv, gv, H);

        // === 纯RFO：直接应用计算出的步长，无任何限制 ===
        Matrix coordNew = xnew.reshape(nAtom, 3);
        cell.coords = coordNew;  // 直接使用RFO计算的新坐标

        std::cout << std::endl;
    }

    return false; // 未达成收敛
}
